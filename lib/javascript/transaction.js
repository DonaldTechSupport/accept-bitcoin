// Generated by CoffeeScript 1.6.3
var Transaction, bitcore, request,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

bitcore = require('bitcore');

request = require('request');

Transaction = (function() {
  function Transaction(key, settings) {
    this.key = key;
    this.settings = settings;
    this.transferPayment = __bind(this.transferPayment, this);
    this.getUnspent = __bind(this.getUnspent, this);
  }

  Transaction.prototype.checkBalance = function(o, cb) {
    var address, includeUnconfirmed;
    this.cb = cb;
    address = o.address || this.key.address();
    includeUnconfirmed = o.includeUnconfirmed || this.settings.includeUnconfirmed;
    if (typeof o === "function") {
      this.cb = o;
    }
    return this.checkBalanceInterval = setInterval(this.getUnspent(address, includeUnconfirmed), this.settings.checkTransactionEvery);
  };

  Transaction.prototype.getUnspent = function(address, includeUnconfirmed) {
    var _this = this;
    console.log('checking');
    if ((this.settings.checkTransactionMaxAttempts -= 1) < 0) {
      clearInterval(this.checkBalanceInterval);
      this.cb('maxAttempts');
      return;
    }
    return request.get("http://" + (this.settings.network === bitcore.networks.testnet ? 't' : '') + "btc.blockr.io/api/v1/address/unspent/" + address + (includeUnconfirmed ? '?unconfirmed=1' : ''), function(error, response, body) {
      var tx, unspent, _ref, _ref1;
      body = JSON.parse(body);
      if (!(body.status === 'success' && ((_ref = body.data) != null ? (_ref1 = _ref.unspent) != null ? _ref1.length : void 0 : void 0) > 0)) {
        return null;
      }
      clearInterval(_this.checkBalanceInterval);
      unspent = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = body.data.unspent;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tx = _ref2[_i];
          if (tx.confirmations >= this.settings.minimumConfirmations) {
            _results.push(this.uotxToHash(tx));
          }
        }
        return _results;
      }).call(_this);
      if (_this.cb) {
        return _this.cb(null, unspent);
      }
    });
  };

  Transaction.prototype.transferPayment = function(payToAddress, o, cb) {
    var _this = this;
    if (o == null) {
      o = {};
    }
    if (!payToAddress) {
      return cb('must have payToAddress');
    }
    return checkBalance({
      address: this.key.address()
    }, function(err, unspent) {
      var options, outs, transferAmount, tx, txHex;
      transferAmount = o.transferAmount || unspent.reduce((function(tot, o) {
        return tot + parseFloat(o.amount);
      }), 0);
      outs = [
        {
          address: payToAddress,
          amount: transferAmount
        }
      ];
      options = {
        remainderOut: {
          address: o.payReminderToAddress || _this.settings.payReminderToAddress || _this.key.address()
        }
      };
      tx = new bitcore.TransactionBuilder(options).setUnspent(unspent).setOutputs(outs).sign(_this.key.privateKey()).build();
      txHex = tx.serialize().toString('hex');
      console.log('builder hex', txHex);
      return cb(null, txHex);
    });
  };

  Transaction.prototype.uotxToHash = function(o) {
    return {
      txid: o.tx,
      vout: o.n,
      address: this.address,
      scriptPubKey: o.script,
      amount: o.amount,
      confirmations: o.confirmations
    };
  };

  return Transaction;

})();

module.exports = Transaction;
