// Generated by CoffeeScript 1.6.3
(function() {
  var Transaction, bitcore, request,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  bitcore = require('bitcore');

  request = require('request');

  Transaction = (function() {
    function Transaction(key, settings) {
      this.key = key;
      this.settings = settings;
      this.pushTx = __bind(this.pushTx, this);
      this.transferPaymentHash = __bind(this.transferPaymentHash, this);
      this.getUnspent = __bind(this.getUnspent, this);
    }

    Transaction.prototype.checkBalance = function(o, cb) {
      var address, includeUnconfirmed;
      this.cb = cb;
      address = o.address || this.key.address();
      includeUnconfirmed = o.includeUnconfirmed || this.settings.includeUnconfirmed;
      if (o instanceof Function) {
        this.cb = o;
      }
      return this.checkBalanceInterval = setInterval(this.getUnspent(address, includeUnconfirmed), this.settings.checkTransactionEvery);
    };

    Transaction.prototype.getUnspent = function(address, includeUnconfirmed) {
      var _this = this;
      console.log('checking');
      if ((this.settings.checkTransactionMaxAttempts -= 1) < 0) {
        clearInterval(this.checkBalanceInterval);
        this.cb('maxAttempts');
        return;
      }
      return request.get("http://" + (this.settings.network === bitcore.networks.testnet ? 't' : '') + "btc.blockr.io/api/v1/address/unspent/" + address + (includeUnconfirmed ? '?unconfirmed=1' : ''), function(error, response, body) {
        var tx, unspent, _ref, _ref1;
        body = JSON.parse(body);
        if (!(body.status === 'success' && ((_ref = body.data) != null ? (_ref1 = _ref.unspent) != null ? _ref1.length : void 0 : void 0) > 0)) {
          return null;
        }
        clearInterval(_this.checkBalanceInterval);
        unspent = (function() {
          var _i, _len, _ref2, _results;
          _ref2 = body.data.unspent;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            tx = _ref2[_i];
            if (tx.confirmations >= this.settings.minimumConfirmations) {
              _results.push(this.uotxToHash(body.data.address, tx));
            }
          }
          return _results;
        }).call(_this);
        if (_this.cb) {
          return _this.cb(null, unspent);
        }
      });
    };

    Transaction.prototype.transferPaymentHash = function(payToAddress, o, cb) {
      var _this = this;
      if (o == null) {
        o = {};
      }
      if (!payToAddress) {
        return cb('must have payToAddress');
      }
      return this.checkBalance({
        address: this.key.address()
      }, function(err, unspent) {
        var options, outs, transferAmount, tx, txHex;
        transferAmount = o.transferAmount || unspent.reduce((function(tot, o) {
          return tot + parseFloat(o.amount);
        }), 0);
        outs = [
          {
            address: payToAddress,
            amount: transferAmount
          }
        ];
        options = {
          remainderOut: {
            address: o.payReminderToAddress || _this.settings.payReminderToAddress || _this.key.address()
          }
        };
        tx = new bitcore.TransactionBuilder(options).setUnspent(unspent).setOutputs(outs).sign([_this.key.privateKey()]).build();
        txHex = tx.serialize().toString('hex');
        return cb(null, txHex);
      });
    };

    Transaction.prototype.pushTx = function(payToAddress, o, cb) {
      var _this = this;
      if (o == null) {
        o = {};
      }
      return this.transferPaymentHash(payToAddress, o, function(err, hex) {
        return request.post({
          url: "http://" + (_this.settings.network === bitcore.networks.testnet ? 't' : '') + "btc.blockr.io/api/v1/tx/push",
          json: {
            hex: hex
          }
        }, function(error, response, body) {
          return cb(err, body);
        });
      });
    };

    Transaction.prototype.uotxToHash = function(address, o) {
      return {
        txid: o.tx,
        vout: o.n,
        address: address,
        scriptPubKey: o.script,
        amount: o.amount,
        confirmations: o.confirmations
      };
    };

    return Transaction;

  })();

  module.exports = Transaction;

}).call(this);
