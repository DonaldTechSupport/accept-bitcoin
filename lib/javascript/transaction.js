// Generated by CoffeeScript 1.6.3
var Transaction, bitcore, request,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

bitcore = require('bitcore');

request = require('request');

Transaction = (function() {
  function Transaction(key, settings) {
    this.key = key;
    this.settings = settings;
    this.transferPayment = __bind(this.transferPayment, this);
    this.getUnspent = __bind(this.getUnspent, this);
  }

  Transaction.prototype.checkBalance = function(cb) {
    this.cb = cb;
    this.address = '14nsgXjL7xCEXFf8UkGCm9KnSTTFBDKqcn';
    return this.checkBalanceInterval = setInterval(this.getUnspent(), this.settings.checkTransactionEvery);
  };

  Transaction.prototype.getUnspent = function() {
    var _this = this;
    console.log('checking');
    if ((this.settings.checkTransactionMaxAttempts -= 1) < 0) {
      clearInterval(this.checkBalanceInterval);
      this.cb('maxAttempts');
      return;
    }
    return request.get("http://btc.blockr.io/api/v1/address/unspent/" + this.address, function(error, response, body) {
      var tx, _ref, _ref1;
      body = JSON.parse(body);
      if (!(body.status === 'success' && ((_ref = body.data) != null ? (_ref1 = _ref.unspent) != null ? _ref1.length : void 0 : void 0) > 0)) {
        return null;
      }
      clearInterval(_this.checkBalanceInterval);
      _this.unspent = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = body.data.unspent;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tx = _ref2[_i];
          if (tx.confirmations >= this.settings.minimumConfirmations) {
            _results.push(this.uotxToHash(tx));
          }
        }
        return _results;
      }).call(_this);
      if (_this.cb) {
        return _this.cb(null, _this.unspent);
      }
    });
  };

  Transaction.prototype.transferPayment = function(o, cb) {
    var opts, outs, tot_amount, tx, txHex;
    if (o == null) {
      o = {};
    }
    tot_amount = this.unspent.reduce((function(tot, o) {
      return tot + parseFloat(o.amount);
    }), 0);
    console.log("tot_amount", tot_amount);
    outs = {
      address: this.settings.payToAddress,
      amount: tot_amount
    };
    opts = {
      remainderOut: {
        address: this.settings.payReminderToAddress
      }
    };
    tx = new bitcore.TransactionBuilder(opts).setUnspent(this.unspent).setOutputs(outs).sign(this.key.privateKey()).build();
    txHex = tx.serialize().toString('hex');
    return cb(null, txHex);
  };

  Transaction.prototype.uotxToHash = function(o) {
    return {
      txid: o.tx,
      vout: o.n,
      address: this.address,
      scriptPubKey: o.script,
      amount: o.amount,
      confirmations: o.confirmations
    };
  };

  return Transaction;

})();

module.exports = Transaction;
