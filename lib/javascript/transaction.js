// Generated by CoffeeScript 1.6.3
var Transaction, bitcore, request,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

bitcore = require('bitcore');

request = require('request');

Transaction = (function() {
  function Transaction(key, settings) {
    this.key = key;
    this.settings = settings;
    this.transferPayment = __bind(this.transferPayment, this);
  }

  Transaction.prototype.checkBalance = function(o, cb) {
    var address, includeUnconfirmed,
      _this = this;
    this.cb = cb;
    address = o.address || this.key.address();
    includeUnconfirmed = o.includeUnconfirmed || settings.includeUnconfirmed;
    this.checkBalanceInterval = setInterval(this.getUnspent(), this.settings.checkTransactionEvery);
    return {
      getUnspent: function() {
        console.log('checking');
        if ((_this.settings.checkTransactionMaxAttempts -= 1) < 0) {
          clearInterval(_this.checkBalanceInterval);
          _this.cb('maxAttempts');
          return;
        }
        return request.get("http://btc.blockr.io/api/v1/address/unspent/" + address + (includeUnconfirmed ? '?unconfirmed=1' : null), function(error, response, body) {
          var tx, _ref, _ref1;
          body = JSON.parse(body);
          if (!(body.status === 'success' && ((_ref = body.data) != null ? (_ref1 = _ref.unspent) != null ? _ref1.length : void 0 : void 0) > 0)) {
            return null;
          }
          clearInterval(_this.checkBalanceInterval);
          _this.unspent = (function() {
            var _i, _len, _ref2, _results;
            _ref2 = body.data.unspent;
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              tx = _ref2[_i];
              if (tx.confirmations >= this.settings.minimumConfirmations) {
                _results.push(this.uotxToHash(tx));
              }
            }
            return _results;
          }).call(_this);
          if (_this.cb) {
            return _this.cb(null, _this.unspent);
          }
        });
      }
    };
  };

  Transaction.prototype.transferPayment = function(o, cb) {
    var _this = this;
    if (o == null) {
      o = {};
    }
    if (!o.payToAddress) {
      return cb('must have payToAddress');
    }
    return checkBalance({
      address: this.key.address()
    }, function(err, unspent) {
      var key, options, outs, transferAmount, tx, txHex;
      transferAmount = o.transferAmount || unspent.reduce((function(tot, o) {
        return tot + parseFloat(o.amount);
      }), 0);
      outs = {
        address: o.payToAddress,
        amount: transferAmount
      };
      options = {
        remainderOut: {
          address: o.payReminderToAddress || _this.settings.payReminderToAddress || _this.key.address()
        }
      };
      key = o.privateKey || _this.key.privateKey();
      tx = new bitcore.TransactionBuilder(options).setUnspent(unspent).setOutputs(outs).sign(key).build();
      txHex = tx.serialize().toString('hex');
      console.log('builder hex', txHex);
      return cb(null, txHex);
    });
  };

  Transaction.prototype.check = function(address, cb) {
    if (this.unspent) {
      return cb(null);
    } else {
      return checkBalance({
        address: address
      }, function(err, unspent) {
        return cb(err, unspent);
      });
    }
  };

  Transaction.prototype.uotxToHash = function(o) {
    return {
      txid: o.tx,
      vout: o.n,
      address: this.address,
      scriptPubKey: o.script,
      amount: o.amount,
      confirmations: o.confirmations
    };
  };

  return Transaction;

})();

module.exports = Transaction;
