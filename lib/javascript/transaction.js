// Generated by CoffeeScript 1.6.3
var Transaction, bitcore, request,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

bitcore = require('bitcore');

request = require('request');

Transaction = (function() {
  function Transaction(key, settings) {
    this.key = key;
    this.settings = settings;
    this.getUnspent = __bind(this.getUnspent, this);
  }

  Transaction.prototype.checkBalance = function(cb) {
    this.cb = cb;
    this.address = '14nsgXjL7xCEXFf8UkGCm9KnSTTFBDKqcn';
    return this.checkBalanceInterval = setInterval(this.getUnspent(this.address), this.settings.checkTransactionEvery);
  };

  Transaction.prototype.getUnspent = function() {
    var _this = this;
    console.log('checking');
    if ((this.settings.checkTransactionMaxAttempts -= 1) < 0) {
      clearInterval(this.checkBalanceInterval);
      this.cb('maxAttempts');
      return;
    }
    request.get("http://btc.blockr.io/api/v1/address/unspent/" + this.address, function(error, response, body) {
      var keys, opts, outs, tot_amount, tx, unspent, _ref, _ref1;
      body = JSON.parse(body);
      if (!(body.status === 'success' && ((_ref = body.data) != null ? (_ref1 = _ref.unspent) != null ? _ref1.length : void 0 : void 0) > 0)) {
        return null;
      }
      clearInterval(_this.checkBalanceInterval);
      unspent = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = body.data.unspent;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tx = _ref2[_i];
          if (tx.confirmations >= this.settings.minimumConfirmations) {
            _results.push(this.uotxToHash(tx));
          }
        }
        return _results;
      }).call(_this);
      tot_amount = unspent.reduce((function(tot, o) {
        return tot + parseFloat(o.amount);
      }), 0);
      console.log("tot_amount", tot_amount);
      outs = {
        address: _this.settings.payToAddress,
        amount: tot_amount
      };
      keys = [_this.key.privateKey];
      opts = {
        remainderOut: {
          address: _this.settings.payToAddress
        }
      };
      if (_this.cb) {
        return _this.cb(null, unspent);
      }
    });
    return {
      transferPayment: function() {}
    };
  };

  Transaction.prototype.uotxToHash = function(o) {
    return {
      txid: o.tx,
      vout: o.n,
      address: this.address,
      scriptPubKey: o.script,
      amount: o.amount,
      confirmations: o.confirmations
    };
  };

  return Transaction;

})();

module.exports = Transaction;
